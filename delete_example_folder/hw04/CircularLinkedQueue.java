package edu.iastate.cs228.hw04;/** *  * @author Steven Sheets *  *         NOTE: 0. Put your Firstname and Lastname after above author tag. Make *         sure that in both cases the first letter is uppercase and all others *         are lowercase (and space in between). 1. You are allowed to create *         and use your own private helper methods. 2. No additional data fields *         can be introduced. 3. No custom classes of your own can be introduced *         or used. 4. Import statements are not allowed. 5. Fully qualified *         class names usage is not allowed. 6. You are allowed to reuse any *         part of the source codes provided or shown under lecture notes of *         week 5 (or before). 7. You are not allowed to create arrays of *         objects and manipulate queue objects using arrays. * * * *         DESCRIPTION: A class that implements the ADT queue by using a *         circular linked chain of nodes. For details of circular linked chain *         check slide number 28 of *         "queueDequePriorityQueueImplementations_part2.pdf" file under lecture *         notes of Wednesday of Week 5 on Canvas. This slide shows a circular *         linked chain with an external reference to its last node that (a) *         shows a case when we have more than one node; (b) has one node; (c) *         is empty. *  *         // Slide number 28 *         file:///U:/Fall%202018%20Courses/COM_S_228__Introduction_to_Data_Structures/Lecture_Notes/Week%205/09-19-2018%20-%20queueDequePriorityQueueImplementations_part2.pdf */public class CircularLinkedQueue<T> implements QueueInterface<T>{	private Node lastNode; // References node for back of queue		public CircularLinkedQueue()	{		lastNode = null;	}		/**	 * Adds a new entry to the back of this queue.	 * 	 * @param newEntry An object to be added.	 */	public void enqueue(T newEntry)	{ // TODO		Node newNode = new Node(newEntry, null);				if (isEmpty())		{			newNode.next = newNode;			lastNode = newNode;		}				else		{			Node temp = lastNode.next;			newNode.next = temp;			lastNode.next = newNode;			lastNode = newNode;		}			}		/**	 * Removes and returns the entry at the front of this queue.	 * 	 * @return The object at the front of the queue.	 * @throws EmptyQueueException if the queue is empty before the operation.	 */	public T dequeue()	{ // TODO		if (isEmpty())		{			throw new EmptyQueueException();		}				T removedFront = null;				if (lastNode.getNextNode().equals(lastNode))		{			removedFront = lastNode.getData();			lastNode = null;		}				else		{			removedFront = lastNode.getNextNode().getData();			lastNode.setNextNode(lastNode.getNextNode().getNextNode());		}				return removedFront;			}		/**	 * Retrieves the entry at the front of this queue.	 * 	 * @return The object at the front of the queue.	 * 	 * @throws EmptyQueueException if the queue is empty.	 */	public T getFront()	{ // TODO		if (isEmpty())		{			throw new EmptyQueueException();		}				return lastNode.getNextNode().getData();	}		/**	 * Detects whether this queue is empty.	 * 	 * @return True if the queue is empty, or false otherwise.	 */	public boolean isEmpty()	{ // TODO		return lastNode == null;	}		/**	 * Removes all entries from this queue.	 */	public void clear()	{ // TODO		lastNode = null; // If the the only instance variable we have to step into and traverse our nodes							// is made null, then everything else becomes unaccessible.	}		private class Node	{		private T data; // Queue entry		private Node next; // Link to next node				private Node(T dataPortion)		{			data = dataPortion;			next = null;		} // end constructor				private Node(T dataPortion, Node linkPortion)		{			data = dataPortion;			next = linkPortion;		} // end constructor				private T getData()		{			return data;		} // end getData				@SuppressWarnings("unused")		private void setData(T newData)		{			data = newData;		} // end setData				private Node getNextNode()		{			return next;		} // end getNextNode				private void setNextNode(Node nextNode)		{			next = nextNode;		} // end setNextNode			} // end Node	} // end CircularLinkedQueue