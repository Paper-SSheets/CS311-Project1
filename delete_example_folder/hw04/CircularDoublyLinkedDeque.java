package edu.iastate.cs228.hw04;/** *  * @author Steven Sheets *  *         NOTE: 0. Put your Firstname and Lastname after above author tag. Make *         sure that in both cases the first letter is uppercase and all others *         are lowercase (and a space). 1. You are allowed to create and use *         your own private helper methods. 2. No additional data fields can be *         introduced. 3. No custom classes of your own can be introduced or *         used. 4. Import statements are not allowed. 5. Fully qualified class *         names usage is not allowed. 6. You are allowed to reuse any part of *         the source codes provided or shown in lecture notes of week 5 (or *         before). 7. You are not allowed to create arrays of objects and *         manipulate queue objects using arrays. * * *         DESCRIPTION: A class that implements the ADT deque by using a *         "circular doubly linked chain" of nodes. In doubly linked chain, the *         first and last nodes each contain one null reference, since the first *         node has no previous node and the last node has no node after it. *         (For details of doubly linked chain implementation of deque, check *         slide number 3 of "queueDequePriorityQueueImplementations_part3.pdf" *         file under lecture notes of Friday of Week 5 on Canvas.) In a *         "circular doubly linked chain", the first node references the last *         node, and the last node references the first. Only one external *         reference is necessary - a reference to the first node - since you *         can quickly get to the last node from the first node. *  *         // Slide Number 3 *         file:///U:/Fall%202018%20Courses/COM_S_228__Introduction_to_Data_Structures/Lecture_Notes/Week%205/09-21-2018%20-%20queueDequePriorityQueueImplementations_part3.pdf *  */public class CircularDoublyLinkedDeque<T> implements DequeInterface<T>{	private DLNode firstNode; // References node for front of deque		public CircularDoublyLinkedDeque()	{		firstNode = null;	} // end default constructor		/**	 * Adds a new entry to the back of this dequeue.	 * 	 * @param newEntry An object to be added.	 */	public void addToBack(T newEntry)	{ // TODO		DLNode newNode = new DLNode(newEntry);				if (isEmpty())		{			firstNode = newNode;			firstNode.setNextNode(firstNode);			firstNode.setPreviousNode(firstNode);		}				else		{			firstNode.getPreviousNode().setNextNode(newNode);			newNode.setNextNode(firstNode);			newNode.setPreviousNode(firstNode.getPreviousNode());			firstNode.setPreviousNode(newNode);		}	}		/**	 * Adds a new entry to the front of this dequeue.	 * 	 * @param newEntry An object to be added.	 */	public void addToFront(T newEntry)	{ // TODO		addToBack(newEntry);		firstNode = firstNode.getPreviousNode();	}		/**	 * Retrieves the front entry of this dequeue.	 * 	 * @return The object at the front/back of the dequeue.	 * @throws EmptyQueueException if the dequeue is empty before the operation.	 */	public T getFront()	{ // TODO		if (isEmpty())		{			throw new EmptyQueueException();		}				return firstNode.getData();	}		/**	 * Retrieves the back entry of this dequeue.	 * 	 * @return The object at the back of the dequeue.	 * @throws EmptyQueueException if the dequeue is empty before the operation.	 */	public T getBack()	{ // TODO		if (isEmpty())		{			throw new EmptyQueueException();		}		return firstNode.getPreviousNode().getData();	}		/**	 * Removes and returns the front entry of this dequeue.	 * 	 * @return The object at the front of the dequeue.	 * @throws EmptyQueueException if the dequeue is empty before the operation.	 */	public T removeFront()	{ // TODO		if (isEmpty())		{			throw new EmptyQueueException();		}				firstNode = firstNode.getNextNode();		return removeBack();	}		/**	 * Removes and returns the back entry of this dequeue.	 * 	 * @return The object at the back of the dequeue.	 * @throws EmptyQueueException if the dequeue is empty before the operation.	 */	public T removeBack()	{ // TODO		if (isEmpty())		{			throw new EmptyQueueException();		}				T toReturn = firstNode.getPreviousNode().getData();				if (firstNode.getNextNode() == firstNode)		{			clear();		}				else		{			firstNode.getPreviousNode().getPreviousNode().setNextNode(firstNode);			firstNode.setPreviousNode(firstNode.getPreviousNode().getPreviousNode());		}				return toReturn;	}		/**	 * Removes all entries from this dequeue.	 */	public void clear()	{ // TODO		firstNode = null;	}		/**	 * Detects whether this dequeue is empty.	 * 	 * @return True if the queue is empty, or false otherwise.	 */	public boolean isEmpty()	{ // TODO		return firstNode == null;	}		private class DLNode	{		private T data; // Deque entry		private DLNode next; // Link to next node		private DLNode previous; // Link to previous node				private DLNode()		{			this(null, null, null);		} // end default constructor				private DLNode(T dataPortion)		{			this(null, dataPortion, null);		} // end constructor				private DLNode(DLNode previousNode, T dataPortion, DLNode nextNode)		{			data = dataPortion;			next = nextNode;			previous = previousNode;		} // end constructor				private T getData()		{			return data;		} // end getData				@SuppressWarnings("unused")		private void setData(T newData)		{			data = newData;		} // end setData				private DLNode getNextNode()		{			return next;		} // end getNextNode				private void setNextNode(DLNode nextNode)		{			next = nextNode;		} // end setNextNode				private DLNode getPreviousNode()		{			return previous;		} // end getPreviousNode				private void setPreviousNode(DLNode previousNode)		{			previous = previousNode;		} // end setPreviousNode	} // end DLNode	} // end CircularDoublyLinkedDeque